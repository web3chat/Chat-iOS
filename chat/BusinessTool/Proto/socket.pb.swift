// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: socket.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PbSkt_Op: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case auth // = 1
  case authReply // = 2
  case heartbeat // = 3
  case heartbeatReply // = 4
  case disconnect // = 5
  case disconnectReply // = 6
  case sendMsg // = 7

  ///客户端回复消息已收到
  case sendMsgReply // = 8
  case receiveMsg // = 9
  case receiveMsgReply // = 10
  case protoReady // = 11
  case protoFinish // = 12
  case raw // = 13
  case syncMsgReq // = 14
  case syncMsgReply // = 15
  case rePush // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .auth
    case 2: self = .authReply
    case 3: self = .heartbeat
    case 4: self = .heartbeatReply
    case 5: self = .disconnect
    case 6: self = .disconnectReply
    case 7: self = .sendMsg
    case 8: self = .sendMsgReply
    case 9: self = .receiveMsg
    case 10: self = .receiveMsgReply
    case 11: self = .protoReady
    case 12: self = .protoFinish
    case 13: self = .raw
    case 14: self = .syncMsgReq
    case 15: self = .syncMsgReply
    case 16: self = .rePush
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .auth: return 1
    case .authReply: return 2
    case .heartbeat: return 3
    case .heartbeatReply: return 4
    case .disconnect: return 5
    case .disconnectReply: return 6
    case .sendMsg: return 7
    case .sendMsgReply: return 8
    case .receiveMsg: return 9
    case .receiveMsgReply: return 10
    case .protoReady: return 11
    case .protoFinish: return 12
    case .raw: return 13
    case .syncMsgReq: return 14
    case .syncMsgReply: return 15
    case .rePush: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbSkt_Op: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbSkt_Op] = [
    .undefined,
    .auth,
    .authReply,
    .heartbeat,
    .heartbeatReply,
    .disconnect,
    .disconnectReply,
    .sendMsg,
    .sendMsgReply,
    .receiveMsg,
    .receiveMsgReply,
    .protoReady,
    .protoFinish,
    .raw,
    .syncMsgReq,
    .syncMsgReply,
    .rePush,
  ]
}

#endif  // swift(>=4.2)

struct PbSkt_Skt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ver: Int32 = 0

  var op: Int32 = 0

  var seq: Int32 = 0

  var ack: Int32 = 0

  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Proto 中 Op 为 OpAuth 时， body 必须可以反序列化为 AuthMsg
struct PbSkt_AuthMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var token: String = String()

  /// 其它业务方可能需要的信息
  var ext: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Proto 中 Op 为 SendMsgReply 时， body 必须可以反序列化为 SendMsgAck
struct PbSkt_SyncMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_PushMsgReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [String] = []

  var protoOp: Int32 = 0

  var proto: PbSkt_Skt {
    get {return _proto ?? PbSkt_Skt()}
    set {_proto = newValue}
  }
  /// Returns true if `proto` has been explicitly set.
  var hasProto: Bool {return self._proto != nil}
  /// Clears the value of `proto`. Subsequent reads from it will return its default value.
  mutating func clearProto() {self._proto = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proto: PbSkt_Skt? = nil
}

struct PbSkt_PushMsgReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: Dictionary<String,Int32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_BroadcastReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protoOp: Int32 = 0

  var proto: PbSkt_Skt {
    get {return _proto ?? PbSkt_Skt()}
    set {_proto = newValue}
  }
  /// Returns true if `proto` has been explicitly set.
  var hasProto: Bool {return self._proto != nil}
  /// Clears the value of `proto`. Subsequent reads from it will return its default value.
  mutating func clearProto() {self._proto = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proto: PbSkt_Skt? = nil
}

struct PbSkt_BroadcastReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_BroadcastGroupReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: String = String()

  var proto: PbSkt_Skt {
    get {return _proto ?? PbSkt_Skt()}
    set {_proto = newValue}
  }
  /// Returns true if `proto` has been explicitly set.
  var hasProto: Bool {return self._proto != nil}
  /// Clears the value of `proto`. Subsequent reads from it will return its default value.
  mutating func clearProto() {self._proto = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proto: PbSkt_Skt? = nil
}

struct PbSkt_BroadcastGroupReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_JoinGroupsReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [String] = []

  var gid: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_JoinGroupsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_LeaveGroupsReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [String] = []

  var gid: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_LeaveGroupsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_DelGroupsReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gid: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbSkt_DelGroupsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pbSkt"

extension PbSkt_Op: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Undefined"),
    1: .same(proto: "Auth"),
    2: .same(proto: "AuthReply"),
    3: .same(proto: "Heartbeat"),
    4: .same(proto: "HeartbeatReply"),
    5: .same(proto: "Disconnect"),
    6: .same(proto: "DisconnectReply"),
    7: .same(proto: "SendMsg"),
    8: .same(proto: "SendMsgReply"),
    9: .same(proto: "ReceiveMsg"),
    10: .same(proto: "ReceiveMsgReply"),
    11: .same(proto: "ProtoReady"),
    12: .same(proto: "ProtoFinish"),
    13: .same(proto: "Raw"),
    14: .same(proto: "SyncMsgReq"),
    15: .same(proto: "SyncMsgReply"),
    16: .same(proto: "RePush"),
  ]
}

extension PbSkt_Skt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Skt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "op"),
    3: .same(proto: "seq"),
    4: .same(proto: "ack"),
    5: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.op) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.seq) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ack) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.op != 0 {
      try visitor.visitSingularInt32Field(value: self.op, fieldNumber: 2)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt32Field(value: self.seq, fieldNumber: 3)
    }
    if self.ack != 0 {
      try visitor.visitSingularInt32Field(value: self.ack, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_Skt, rhs: PbSkt_Skt) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.op != rhs.op {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.ack != rhs.ack {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_AuthMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "token"),
    3: .same(proto: "ext"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.ext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ext, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_AuthMsg, rhs: PbSkt_AuthMsg) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.ext != rhs.ext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_SyncMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.logID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logID != 0 {
      try visitor.visitSingularInt64Field(value: self.logID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_SyncMsg, rhs: PbSkt_SyncMsg) -> Bool {
    if lhs.logID != rhs.logID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_Empty, rhs: PbSkt_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_PushMsgReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushMsgReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "protoOp"),
    3: .same(proto: "proto"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.protoOp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proto) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if self.protoOp != 0 {
      try visitor.visitSingularInt32Field(value: self.protoOp, fieldNumber: 2)
    }
    if let v = self._proto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_PushMsgReq, rhs: PbSkt_PushMsgReq) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.protoOp != rhs.protoOp {return false}
    if lhs._proto != rhs._proto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_PushMsgReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushMsgReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.index.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_PushMsgReply, rhs: PbSkt_PushMsgReply) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_BroadcastReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoOp"),
    2: .same(proto: "proto"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.protoOp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proto) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protoOp != 0 {
      try visitor.visitSingularInt32Field(value: self.protoOp, fieldNumber: 1)
    }
    if let v = self._proto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_BroadcastReq, rhs: PbSkt_BroadcastReq) -> Bool {
    if lhs.protoOp != rhs.protoOp {return false}
    if lhs._proto != rhs._proto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_BroadcastReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_BroadcastReply, rhs: PbSkt_BroadcastReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_BroadcastGroupReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastGroupReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
    2: .same(proto: "proto"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proto) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if let v = self._proto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_BroadcastGroupReq, rhs: PbSkt_BroadcastGroupReq) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._proto != rhs._proto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_BroadcastGroupReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastGroupReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_BroadcastGroupReply, rhs: PbSkt_BroadcastGroupReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_JoinGroupsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinGroupsReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "gid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.gid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_JoinGroupsReq, rhs: PbSkt_JoinGroupsReq) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_JoinGroupsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinGroupsReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_JoinGroupsReply, rhs: PbSkt_JoinGroupsReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_LeaveGroupsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaveGroupsReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "gid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.gid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_LeaveGroupsReq, rhs: PbSkt_LeaveGroupsReq) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_LeaveGroupsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaveGroupsReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_LeaveGroupsReply, rhs: PbSkt_LeaveGroupsReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_DelGroupsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelGroupsReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.gid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_DelGroupsReq, rhs: PbSkt_DelGroupsReq) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbSkt_DelGroupsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelGroupsReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbSkt_DelGroupsReply, rhs: PbSkt_DelGroupsReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
