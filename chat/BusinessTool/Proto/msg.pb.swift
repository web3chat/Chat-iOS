// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: msg.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PbMsg_Device: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case android // = 0
  case ios // = 1
  case windows // = 2
  case linux // = 3
  case macOs // = 4
  case web // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .android
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .android
    case 1: self = .ios
    case 2: self = .windows
    case 3: self = .linux
    case 4: self = .macOs
    case 5: self = .web
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .android: return 0
    case .ios: return 1
    case .windows: return 2
    case .linux: return 3
    case .macOs: return 4
    case .web: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_Device: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_Device] = [
    .android,
    .ios,
    .windows,
    .linux,
    .macOs,
    .web,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_EventType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///普通消息
  case message // = 0

  ///消息回复
  case messageAck // = 1

  ///通知信令
  case notice // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .message
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .message
    case 1: self = .messageAck
    case 2: self = .notice
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .message: return 0
    case .messageAck: return 1
    case .notice: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_EventType] = [
    .message,
    .messageAck,
    .notice,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_MsgType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///系统消息
  case system // = 0

  ///文本消息
  case text // = 1

  ///音频消息
  case audio // = 2

  ///图片消息
  case image // = 3

  ///视频消息
  case video // = 4

  ///文件消息
  case file // = 5

  ///卡片消息(客户端忽略该类型消息，服务端在其他地方使用该类型)
  case card // = 6

  ///通知消息
  case notification // = 7

  ///合并转发
  case forward // = 8
  case rtccall // = 9
  case transfer // = 10
  case collect // = 11
  case redPacket // = 12
  case contactCard // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .system
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .system
    case 1: self = .text
    case 2: self = .audio
    case 3: self = .image
    case 4: self = .video
    case 5: self = .file
    case 6: self = .card
    case 7: self = .notification
    case 8: self = .forward
    case 9: self = .rtccall
    case 10: self = .transfer
    case 11: self = .collect
    case 12: self = .redPacket
    case 13: self = .contactCard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .system: return 0
    case .text: return 1
    case .audio: return 2
    case .image: return 3
    case .video: return 4
    case .file: return 5
    case .card: return 6
    case .notification: return 7
    case .forward: return 8
    case .rtccall: return 9
    case .transfer: return 10
    case .collect: return 11
    case .redPacket: return 12
    case .contactCard: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_MsgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_MsgType] = [
    .system,
    .text,
    .audio,
    .image,
    .video,
    .file,
    .card,
    .notification,
    .forward,
    .rtccall,
    .transfer,
    .collect,
    .redPacket,
    .contactCard,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_RPType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case randomAmount // = 0
  case identicalAmount // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .randomAmount
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .randomAmount
    case 1: self = .identicalAmount
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .randomAmount: return 0
    case .identicalAmount: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_RPType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_RPType] = [
    .randomAmount,
    .identicalAmount,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_CardType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case personal // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .personal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .personal: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_CardType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_CardType] = [
    .undefined,
    .personal,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_NotificationType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///修改群名
  case notiUpdateGroupName // = 0

  ///加群
  case notiSignInGroup // = 1

  ///退群
  case notiSignOutGroup // = 2

  ///踢群
  case notikickOutGroup // = 3

  ///删群
  case notiDeleteGroup // = 4

  ///群禁言模式更改
  case notiUpdateGroupMuted // = 5

  ///更改禁言名单
  case notiUpdateGroupMemberMutedTime // = 6

  ///更换群主
  case notiUpdateGroupOwner // = 7

  ///撤回消息通知，客户端占用
  case msgRevoked // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .notiUpdateGroupName
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notiUpdateGroupName
    case 1: self = .notiSignInGroup
    case 2: self = .notiSignOutGroup
    case 3: self = .notikickOutGroup
    case 4: self = .notiDeleteGroup
    case 5: self = .notiUpdateGroupMuted
    case 6: self = .notiUpdateGroupMemberMutedTime
    case 7: self = .notiUpdateGroupOwner
    case 8: self = .msgRevoked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notiUpdateGroupName: return 0
    case .notiSignInGroup: return 1
    case .notiSignOutGroup: return 2
    case .notikickOutGroup: return 3
    case .notiDeleteGroup: return 4
    case .notiUpdateGroupMuted: return 5
    case .notiUpdateGroupMemberMutedTime: return 6
    case .notiUpdateGroupOwner: return 7
    case .msgRevoked: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_NotificationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_NotificationType] = [
    .notiUpdateGroupName,
    .notiSignInGroup,
    .notiSignOutGroup,
    .notikickOutGroup,
    .notiDeleteGroup,
    .notiUpdateGroupMuted,
    .notiUpdateGroupMemberMutedTime,
    .notiUpdateGroupOwner,
    .msgRevoked,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_ActionType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///送达
  case received // = 0

  ///撤回
  case revoke // = 1

  ///加群
  case signInGroup // = 10

  ///退群
  case signOutGroup // = 11

  ///删群
  case deleteGroup // = 12

  ///关注消息
  case focusMessage // = 13

  ///多端登录
  case endpointLogin // = 14
  case updateGroupJoinType // = 20

  ///更新群加好友权限
  case updateGroupFriendType // = 21

  ///更新群禁言类型
  case updateGroupMuteType // = 22

  ///更新群成员
  case updateGroupMemberType // = 23

  ///更新禁言列表
  case updateGroupMemberMuteTime // = 24

  ///更新群名
  case updateGroupName // = 25

  ///更新群头像
  case updateGroupAvatar // = 26
  case startCall // = 31
  case acceptCall // = 32
  case stopCall // = 33
  case UNRECOGNIZED(Int)

  init() {
    self = .received
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .received
    case 1: self = .revoke
    case 10: self = .signInGroup
    case 11: self = .signOutGroup
    case 12: self = .deleteGroup
    case 13: self = .focusMessage
    case 14: self = .endpointLogin
    case 20: self = .updateGroupJoinType
    case 21: self = .updateGroupFriendType
    case 22: self = .updateGroupMuteType
    case 23: self = .updateGroupMemberType
    case 24: self = .updateGroupMemberMuteTime
    case 25: self = .updateGroupName
    case 26: self = .updateGroupAvatar
    case 31: self = .startCall
    case 32: self = .acceptCall
    case 33: self = .stopCall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .received: return 0
    case .revoke: return 1
    case .signInGroup: return 10
    case .signOutGroup: return 11
    case .deleteGroup: return 12
    case .focusMessage: return 13
    case .endpointLogin: return 14
    case .updateGroupJoinType: return 20
    case .updateGroupFriendType: return 21
    case .updateGroupMuteType: return 22
    case .updateGroupMemberType: return 23
    case .updateGroupMemberMuteTime: return 24
    case .updateGroupName: return 25
    case .updateGroupAvatar: return 26
    case .startCall: return 31
    case .acceptCall: return 32
    case .stopCall: return 33
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_ActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_ActionType] = [
    .received,
    .revoke,
    .signInGroup,
    .signOutGroup,
    .deleteGroup,
    .focusMessage,
    .endpointLogin,
    .updateGroupJoinType,
    .updateGroupFriendType,
    .updateGroupMuteType,
    .updateGroupMemberType,
    .updateGroupMemberMuteTime,
    .updateGroupName,
    .updateGroupAvatar,
    .startCall,
    .acceptCall,
    .stopCall,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_JoinType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case joinAllow // = 0
  case joinDeny // = 1
  case joinApply // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .joinAllow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .joinAllow
    case 1: self = .joinDeny
    case 2: self = .joinApply
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .joinAllow: return 0
    case .joinDeny: return 1
    case .joinApply: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_JoinType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_JoinType] = [
    .joinAllow,
    .joinDeny,
    .joinApply,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_FriendType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case friendAllow // = 0
  case friendDeny // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .friendAllow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .friendAllow
    case 1: self = .friendDeny
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .friendAllow: return 0
    case .friendDeny: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_FriendType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_FriendType] = [
    .friendAllow,
    .friendDeny,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_MuteType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case muteAllow // = 0
  case muteDeny // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .muteAllow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .muteAllow
    case 1: self = .muteDeny
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .muteAllow: return 0
    case .muteDeny: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_MuteType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_MuteType] = [
    .muteAllow,
    .muteDeny,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_MemberType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case admin // = 1
  case owner // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .admin
    case 2: self = .owner
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .admin: return 1
    case .owner: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_MemberType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_MemberType] = [
    .normal,
    .admin,
    .owner,
  ]
}

#endif  // swift(>=4.2)

enum PbMsg_StopCallType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case busy // = 0
  case timeout // = 1
  case reject // = 2
  case hangup // = 3
  case cancel // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .busy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .busy
    case 1: self = .timeout
    case 2: self = .reject
    case 3: self = .hangup
    case 4: self = .cancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .busy: return 0
    case .timeout: return 1
    case .reject: return 2
    case .hangup: return 3
    case .cancel: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PbMsg_StopCallType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_StopCallType] = [
    .busy,
    .timeout,
    .reject,
    .hangup,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

struct PbMsg_Login {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: PbMsg_Device = .android

  var username: String = String()

  var deviceToken: String = String()

  var connType: PbMsg_Login.ConnType = .connect

  var uuid: String = String()

  var deviceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ConnType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case connect // = 0
    case reconnect // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .connect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .connect
      case 1: self = .reconnect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .connect: return 0
      case .reconnect: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension PbMsg_Login.ConnType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PbMsg_Login.ConnType] = [
    .connect,
    .reconnect,
  ]
}

#endif  // swift(>=4.2)

struct PbMsg_event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///事件类型
  var eventType: PbMsg_EventType = .message

  ///消息体
  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_msg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息通道 0 私聊 1 群聊
  var channelType: Int32 = 0

  ///消息id
  var logID: Int64 = 0

  ///客户端序列
  var msgID: String = String()

  ///发送者
  var from: String = String()

  ///接收者
  var target: String = String()

  ///消息类型
  var msgType: PbMsg_MsgType = .system

  ///消息体
  var msg: Data = Data()

  ///事件戳，ms
  var datetime: UInt64 = 0

  ///来源，详见如下
  var source: PbMsg_Source {
    get {return _source ?? PbMsg_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  ///引用
  var reference: PbMsg_Reference {
    get {return _reference ?? PbMsg_Reference()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  mutating func clearReference() {self._reference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: PbMsg_Source? = nil
  fileprivate var _reference: PbMsg_Reference? = nil
}

struct PbMsg_Reference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topic: Int64 = 0

  var ref: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelType: Int32 = 0

  var from: PbMsg_SourceUser {
    get {return _from ?? PbMsg_SourceUser()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var target: PbMsg_SourceUser {
    get {return _target ?? PbMsg_SourceUser()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: PbMsg_SourceUser? = nil
  fileprivate var _target: PbMsg_SourceUser? = nil
}

struct PbMsg_SourceUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Proto 中 Op 为 SendMsgReply 时， body 必须可以反序列化为 SendMsgAck
struct PbMsg_SendMsgAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logID: Int64 = 0

  var datetime: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_EncryptMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_TextMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String = String()

  ///@谁
  var mention: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AudioMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaURL: String = String()

  var time: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ImageMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaURL: String = String()

  var height: Int32 = 0

  var width: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_VideoMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaURL: String = String()

  var time: Int32 = 0

  var height: Int32 = 0

  var width: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_FileMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaURL: String = String()

  var name: String = String()

  var md5: String = String()

  var size: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NotificationMsg 通知消息（群聊内灰色文字通知消息） 注意：body必须可以反序列化为NotificationType相对应的结构体
struct PbMsg_NotificationMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: PbMsg_NotificationType = .notiUpdateGroupName

  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ForwardMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [PbMsg_ForwardItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ForwardItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var avatar: String = String()

  var name: String = String()

  var msgType: Int32 = 0

  var msg: Data = Data()

  var datetime: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_TransferMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txHash: String = String()
  var coinName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_RedPacketMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txHash: String = String()

  var coinName: String = String()

  ///执行器名称 user.p.
  var exec: String = String()

  var packetType: PbMsg_RPType = .randomAmount

  ///客户端创建的私钥（选填）
  var privateKey: String = String()

  var remark: String = String()

  ///到期时间 单位：ms时间戳
  var expire: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ContactCardMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: PbMsg_CardType = .undefined

  var id: String = String()

  var name: String = String()

  var avatar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertUpdateGroupName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertSignInGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var inviter: String = String()

  var members: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertSignOutGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertkickOutGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var members: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertDeleteGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertUpdateGroupMuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var type: PbMsg_MuteType = .muteAllow

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertUpdateGroupMemberMutedTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var `operator`: String = String()

  var members: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_AlertUpdateGroupOwner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var newOwner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 通知信令 alert msg define 页面UI更新消息 注意：body必须可反序列化为ActionType对应的结构体。
struct PbMsg_NotifyMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///信令类型
  var action: PbMsg_ActionType = .received

  ///消息体
  var body: Data = Data()

  var sid: Int64 = 0

  var reliable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logs: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionSignInGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uid: [String] = []

  var group: Int64 = 0

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionSignOutGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uid: [String] = []

  var group: Int64 = 0

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionDeleteGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///关注消息
struct PbMsg_ActionFocusMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mid: Int64 = 0

  var uid: String = String()

  var currentNum: Int32 = 0

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///多端登录
struct PbMsg_ActionEndpointLogin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var device: PbMsg_Device = .android

  var deviceName: String = String()

  var datetime: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupJoinType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var type: PbMsg_JoinType = .joinAllow

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupFriendType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var type: PbMsg_FriendType = .friendAllow

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupMuteType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var type: PbMsg_MuteType = .muteAllow

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupMemberType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var uid: String = String()

  var type: PbMsg_MemberType = .normal

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupMemberMuteTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var uid: [String] = []

  var muteTime: Int64 = 0

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var name: String = String()

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionUpdateGroupAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Int64 = 0

  var avatar: String = String()

  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionStartCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var traceID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionAcceptCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var traceID: Int64 = 0

  var roomID: Int32 = 0

  var uid: String = String()

  var userSig: String = String()

  var privateMapKey: String = String()

  var skdAppID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionStopCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var traceID: Int64 = 0

  var reason: PbMsg_StopCallType = .busy

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PbMsg_ActionRevoke {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logID: Int64 = 0

  var `operator`: String = String()

  var self_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pbMsg"

extension PbMsg_Device: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Android"),
    1: .same(proto: "IOS"),
    2: .same(proto: "Windows"),
    3: .same(proto: "Linux"),
    4: .same(proto: "MacOS"),
    5: .same(proto: "Web"),
  ]
}

extension PbMsg_EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "message"),
    1: .same(proto: "messageAck"),
    2: .same(proto: "notice"),
  ]
}

extension PbMsg_MsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "System"),
    1: .same(proto: "Text"),
    2: .same(proto: "Audio"),
    3: .same(proto: "Image"),
    4: .same(proto: "Video"),
    5: .same(proto: "File"),
    6: .same(proto: "Card"),
    7: .same(proto: "Notification"),
    8: .same(proto: "Forward"),
    9: .same(proto: "RTCCall"),
    10: .same(proto: "Transfer"),
    11: .same(proto: "Collect"),
    12: .same(proto: "RedPacket"),
    13: .same(proto: "ContactCard"),
  ]
}

extension PbMsg_RPType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RandomAmount"),
    1: .same(proto: "IdenticalAmount"),
  ]
}

extension PbMsg_CardType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Undefined"),
    1: .same(proto: "Personal"),
  ]
}

extension PbMsg_NotificationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotiUpdateGroupName"),
    1: .same(proto: "NotiSignInGroup"),
    2: .same(proto: "NotiSignOutGroup"),
    3: .same(proto: "NotikickOutGroup"),
    4: .same(proto: "NotiDeleteGroup"),
    5: .same(proto: "NotiUpdateGroupMuted"),
    6: .same(proto: "NotiUpdateGroupMemberMutedTime"),
    7: .same(proto: "NotiUpdateGroupOwner"),
    8: .same(proto: "MsgRevoked"),
  ]
}

extension PbMsg_ActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Received"),
    1: .same(proto: "Revoke"),
    10: .same(proto: "SignInGroup"),
    11: .same(proto: "SignOutGroup"),
    12: .same(proto: "DeleteGroup"),
    13: .same(proto: "FocusMessage"),
    14: .same(proto: "EndpointLogin"),
    20: .same(proto: "UpdateGroupJoinType"),
    21: .same(proto: "UpdateGroupFriendType"),
    22: .same(proto: "UpdateGroupMuteType"),
    23: .same(proto: "UpdateGroupMemberType"),
    24: .same(proto: "UpdateGroupMemberMuteTime"),
    25: .same(proto: "UpdateGroupName"),
    26: .same(proto: "UpdateGroupAvatar"),
    31: .same(proto: "StartCall"),
    32: .same(proto: "AcceptCall"),
    33: .same(proto: "StopCall"),
  ]
}

extension PbMsg_JoinType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JoinAllow"),
    1: .same(proto: "JoinDeny"),
    2: .same(proto: "JoinApply"),
  ]
}

extension PbMsg_FriendType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FriendAllow"),
    1: .same(proto: "FriendDeny"),
  ]
}

extension PbMsg_MuteType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MuteAllow"),
    1: .same(proto: "MuteDeny"),
  ]
}

extension PbMsg_MemberType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Normal"),
    1: .same(proto: "Admin"),
    2: .same(proto: "Owner"),
  ]
}

extension PbMsg_StopCallType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Busy"),
    1: .same(proto: "Timeout"),
    2: .same(proto: "Reject"),
    3: .same(proto: "Hangup"),
    4: .same(proto: "Cancel"),
  ]
}

extension PbMsg_Login: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Login"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "username"),
    3: .same(proto: "deviceToken"),
    4: .same(proto: "connType"),
    5: .same(proto: "uuid"),
    6: .same(proto: "deviceName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.connType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.device != .android {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.deviceToken.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceToken, fieldNumber: 3)
    }
    if self.connType != .connect {
      try visitor.visitSingularEnumField(value: self.connType, fieldNumber: 4)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 5)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_Login, rhs: PbMsg_Login) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.username != rhs.username {return false}
    if lhs.deviceToken != rhs.deviceToken {return false}
    if lhs.connType != rhs.connType {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_Login.ConnType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Connect"),
    1: .same(proto: "Reconnect"),
  ]
}

extension PbMsg_event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventType"),
    2: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .message {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_event, rhs: PbMsg_event) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_msg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".msg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelType"),
    2: .same(proto: "logId"),
    3: .same(proto: "msgId"),
    4: .same(proto: "from"),
    5: .same(proto: "target"),
    6: .same(proto: "msgType"),
    7: .same(proto: "msg"),
    8: .same(proto: "datetime"),
    9: .same(proto: "source"),
    10: .same(proto: "reference"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.logID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.msgType) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.datetime) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._reference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelType != 0 {
      try visitor.visitSingularInt32Field(value: self.channelType, fieldNumber: 1)
    }
    if self.logID != 0 {
      try visitor.visitSingularInt64Field(value: self.logID, fieldNumber: 2)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 3)
    }
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 4)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 5)
    }
    if self.msgType != .system {
      try visitor.visitSingularEnumField(value: self.msgType, fieldNumber: 6)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 7)
    }
    if self.datetime != 0 {
      try visitor.visitSingularUInt64Field(value: self.datetime, fieldNumber: 8)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._reference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_msg, rhs: PbMsg_msg) -> Bool {
    if lhs.channelType != rhs.channelType {return false}
    if lhs.logID != rhs.logID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.from != rhs.from {return false}
    if lhs.target != rhs.target {return false}
    if lhs.msgType != rhs.msgType {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.datetime != rhs.datetime {return false}
    if lhs._source != rhs._source {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_Reference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ref) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.topic != 0 {
      try visitor.visitSingularInt64Field(value: self.topic, fieldNumber: 1)
    }
    if self.ref != 0 {
      try visitor.visitSingularInt64Field(value: self.ref, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_Reference, rhs: PbMsg_Reference) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.ref != rhs.ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelType"),
    2: .same(proto: "from"),
    3: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelType != 0 {
      try visitor.visitSingularInt32Field(value: self.channelType, fieldNumber: 1)
    }
    if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_Source, rhs: PbMsg_Source) -> Bool {
    if lhs.channelType != rhs.channelType {return false}
    if lhs._from != rhs._from {return false}
    if lhs._target != rhs._target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_SourceUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_SourceUser, rhs: PbMsg_SourceUser) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_SendMsgAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMsgAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "logId"),
    8: .same(proto: "datetime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.logID) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.datetime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logID != 0 {
      try visitor.visitSingularInt64Field(value: self.logID, fieldNumber: 2)
    }
    if self.datetime != 0 {
      try visitor.visitSingularUInt64Field(value: self.datetime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_SendMsgAck, rhs: PbMsg_SendMsgAck) -> Bool {
    if lhs.logID != rhs.logID {return false}
    if lhs.datetime != rhs.datetime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_EncryptMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_EncryptMsg, rhs: PbMsg_EncryptMsg) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_TextMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "mention"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.mention) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if !self.mention.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mention, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_TextMsg, rhs: PbMsg_TextMsg) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.mention != rhs.mention {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AudioMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaUrl"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaURL) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaURL, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AudioMsg, rhs: PbMsg_AudioMsg) -> Bool {
    if lhs.mediaURL != rhs.mediaURL {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ImageMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaUrl"),
    2: .same(proto: "height"),
    3: .same(proto: "width"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaURL) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaURL, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ImageMsg, rhs: PbMsg_ImageMsg) -> Bool {
    if lhs.mediaURL != rhs.mediaURL {return false}
    if lhs.height != rhs.height {return false}
    if lhs.width != rhs.width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_VideoMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaUrl"),
    2: .same(proto: "time"),
    3: .same(proto: "height"),
    4: .same(proto: "width"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaURL) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaURL, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_VideoMsg, rhs: PbMsg_VideoMsg) -> Bool {
    if lhs.mediaURL != rhs.mediaURL {return false}
    if lhs.time != rhs.time {return false}
    if lhs.height != rhs.height {return false}
    if lhs.width != rhs.width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_FileMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaUrl"),
    2: .same(proto: "name"),
    3: .same(proto: "md5"),
    4: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.md5) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaURL, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.md5.isEmpty {
      try visitor.visitSingularStringField(value: self.md5, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_FileMsg, rhs: PbMsg_FileMsg) -> Bool {
    if lhs.mediaURL != rhs.mediaURL {return false}
    if lhs.name != rhs.name {return false}
    if lhs.md5 != rhs.md5 {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_NotificationMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .notiUpdateGroupName {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_NotificationMsg, rhs: PbMsg_NotificationMsg) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ForwardMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ForwardMsg, rhs: PbMsg_ForwardMsg) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ForwardItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
    2: .same(proto: "name"),
    3: .same(proto: "msgType"),
    4: .same(proto: "msg"),
    5: .same(proto: "datetime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.msgType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.datetime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.msgType != 0 {
      try visitor.visitSingularInt32Field(value: self.msgType, fieldNumber: 3)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 4)
    }
    if self.datetime != 0 {
      try visitor.visitSingularUInt64Field(value: self.datetime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ForwardItem, rhs: PbMsg_ForwardItem) -> Bool {
    if lhs.avatar != rhs.avatar {return false}
    if lhs.name != rhs.name {return false}
    if lhs.msgType != rhs.msgType {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.datetime != rhs.datetime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_TransferMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txHash"),
    2: .same(proto: "coinName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.coinName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    if !self.coinName.isEmpty {
      try visitor.visitSingularStringField(value: self.coinName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_TransferMsg, rhs: PbMsg_TransferMsg) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.coinName != rhs.coinName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_RedPacketMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RedPacketMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txHash"),
    2: .same(proto: "coinName"),
    3: .same(proto: "exec"),
    4: .same(proto: "packetType"),
    5: .same(proto: "privateKey"),
    6: .same(proto: "remark"),
    7: .same(proto: "expire"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.coinName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exec) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.packetType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.expire) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    if !self.coinName.isEmpty {
      try visitor.visitSingularStringField(value: self.coinName, fieldNumber: 2)
    }
    if !self.exec.isEmpty {
      try visitor.visitSingularStringField(value: self.exec, fieldNumber: 3)
    }
    if self.packetType != .randomAmount {
      try visitor.visitSingularEnumField(value: self.packetType, fieldNumber: 4)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 5)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 6)
    }
    if self.expire != 0 {
      try visitor.visitSingularUInt64Field(value: self.expire, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_RedPacketMsg, rhs: PbMsg_RedPacketMsg) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.coinName != rhs.coinName {return false}
    if lhs.exec != rhs.exec {return false}
    if lhs.packetType != rhs.packetType {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.expire != rhs.expire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ContactCardMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactCardMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ContactCardMsg, rhs: PbMsg_ContactCardMsg) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertUpdateGroupName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertUpdateGroupName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertUpdateGroupName, rhs: PbMsg_AlertUpdateGroupName) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertSignInGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertSignInGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "inviter"),
    3: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inviter) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.inviter.isEmpty {
      try visitor.visitSingularStringField(value: self.inviter, fieldNumber: 2)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertSignInGroup, rhs: PbMsg_AlertSignInGroup) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.inviter != rhs.inviter {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertSignOutGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertSignOutGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertSignOutGroup, rhs: PbMsg_AlertSignOutGroup) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertkickOutGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertkickOutGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
    3: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertkickOutGroup, rhs: PbMsg_AlertkickOutGroup) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertDeleteGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertDeleteGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertDeleteGroup, rhs: PbMsg_AlertDeleteGroup) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertUpdateGroupMuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertUpdateGroupMuted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    if self.type != .muteAllow {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertUpdateGroupMuted, rhs: PbMsg_AlertUpdateGroupMuted) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertUpdateGroupMemberMutedTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertUpdateGroupMemberMutedTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "operator"),
    3: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertUpdateGroupMemberMutedTime, rhs: PbMsg_AlertUpdateGroupMemberMutedTime) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_AlertUpdateGroupOwner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertUpdateGroupOwner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "newOwner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newOwner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.newOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.newOwner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_AlertUpdateGroupOwner, rhs: PbMsg_AlertUpdateGroupOwner) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.newOwner != rhs.newOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_NotifyMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "body"),
    3: .same(proto: "sid"),
    4: .same(proto: "reliable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reliable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .received {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    if self.sid != 0 {
      try visitor.visitSingularInt64Field(value: self.sid, fieldNumber: 3)
    }
    if self.reliable != false {
      try visitor.visitSingularBoolField(value: self.reliable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_NotifyMsg, rhs: PbMsg_NotifyMsg) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.body != rhs.body {return false}
    if lhs.sid != rhs.sid {return false}
    if lhs.reliable != rhs.reliable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.logs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitPackedInt64Field(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionReceived, rhs: PbMsg_ActionReceived) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionSignInGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSignInGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "group"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uid, fieldNumber: 1)
    }
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionSignInGroup, rhs: PbMsg_ActionSignInGroup) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.group != rhs.group {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionSignOutGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSignOutGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "group"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uid, fieldNumber: 1)
    }
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionSignOutGroup, rhs: PbMsg_ActionSignOutGroup) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.group != rhs.group {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionDeleteGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionDeleteGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionDeleteGroup, rhs: PbMsg_ActionDeleteGroup) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionFocusMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionFocusMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mid"),
    2: .same(proto: "uid"),
    3: .same(proto: "currentNum"),
    4: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.mid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.currentNum) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mid != 0 {
      try visitor.visitSingularInt64Field(value: self.mid, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if self.currentNum != 0 {
      try visitor.visitSingularInt32Field(value: self.currentNum, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionFocusMessage, rhs: PbMsg_ActionFocusMessage) -> Bool {
    if lhs.mid != rhs.mid {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.currentNum != rhs.currentNum {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionEndpointLogin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionEndpointLogin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "device"),
    3: .same(proto: "deviceName"),
    4: .same(proto: "datetime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.datetime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.device != .android {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 2)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 3)
    }
    if self.datetime != 0 {
      try visitor.visitSingularUInt64Field(value: self.datetime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionEndpointLogin, rhs: PbMsg_ActionEndpointLogin) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.device != rhs.device {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.datetime != rhs.datetime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupJoinType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupJoinType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "type"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if self.type != .joinAllow {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupJoinType, rhs: PbMsg_ActionUpdateGroupJoinType) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.type != rhs.type {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupFriendType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupFriendType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "type"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if self.type != .friendAllow {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupFriendType, rhs: PbMsg_ActionUpdateGroupFriendType) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.type != rhs.type {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupMuteType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupMuteType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "type"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if self.type != .muteAllow {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupMuteType, rhs: PbMsg_ActionUpdateGroupMuteType) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.type != rhs.type {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupMemberType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupMemberType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "uid"),
    3: .same(proto: "type"),
    4: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if self.type != .normal {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupMemberType, rhs: PbMsg_ActionUpdateGroupMemberType) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupMemberMuteTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupMemberMuteTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "uid"),
    3: .same(proto: "muteTime"),
    4: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.muteTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uid, fieldNumber: 2)
    }
    if self.muteTime != 0 {
      try visitor.visitSingularInt64Field(value: self.muteTime, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupMemberMuteTime, rhs: PbMsg_ActionUpdateGroupMemberMuteTime) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.muteTime != rhs.muteTime {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "name"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupName, rhs: PbMsg_ActionUpdateGroupName) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.name != rhs.name {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionUpdateGroupAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionUpdateGroupAvatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "avatar"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.group != 0 {
      try visitor.visitSingularInt64Field(value: self.group, fieldNumber: 1)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionUpdateGroupAvatar, rhs: PbMsg_ActionUpdateGroupAvatar) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionStartCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionStartCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.traceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.traceID != 0 {
      try visitor.visitSingularInt64Field(value: self.traceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionStartCall, rhs: PbMsg_ActionStartCall) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionAcceptCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionAcceptCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "room_id"),
    3: .same(proto: "uid"),
    4: .standard(proto: "user_sig"),
    5: .standard(proto: "private_map_key"),
    6: .standard(proto: "skd_app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.roomID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userSig) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.privateMapKey) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.skdAppID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.traceID != 0 {
      try visitor.visitSingularInt64Field(value: self.traceID, fieldNumber: 1)
    }
    if self.roomID != 0 {
      try visitor.visitSingularInt32Field(value: self.roomID, fieldNumber: 2)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 3)
    }
    if !self.userSig.isEmpty {
      try visitor.visitSingularStringField(value: self.userSig, fieldNumber: 4)
    }
    if !self.privateMapKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateMapKey, fieldNumber: 5)
    }
    if self.skdAppID != 0 {
      try visitor.visitSingularInt32Field(value: self.skdAppID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionAcceptCall, rhs: PbMsg_ActionAcceptCall) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.roomID != rhs.roomID {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.userSig != rhs.userSig {return false}
    if lhs.privateMapKey != rhs.privateMapKey {return false}
    if lhs.skdAppID != rhs.skdAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionStopCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionStopCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.traceID != 0 {
      try visitor.visitSingularInt64Field(value: self.traceID, fieldNumber: 1)
    }
    if self.reason != .busy {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionStopCall, rhs: PbMsg_ActionStopCall) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PbMsg_ActionRevoke: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRevoke"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logId"),
    2: .same(proto: "operator"),
    3: .same(proto: "self"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.logID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.self_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logID != 0 {
      try visitor.visitSingularInt64Field(value: self.logID, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    if self.self_p != false {
      try visitor.visitSingularBoolField(value: self.self_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PbMsg_ActionRevoke, rhs: PbMsg_ActionRevoke) -> Bool {
    if lhs.logID != rhs.logID {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.self_p != rhs.self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
